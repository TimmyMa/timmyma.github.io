<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="just some notes">
<meta property="og:type" content="website">
<meta property="og:title" content="Timmy Ma">
<meta property="og:url" content="http://www.mlaboratory.tech/index.html">
<meta property="og:site_name" content="Timmy Ma">
<meta property="og:description" content="just some notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Timmy Ma">
<meta name="twitter:description" content="just some notes">






  <link rel="canonical" href="http://www.mlaboratory.tech/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Timmy Ma</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Timmy Ma</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">to infinity and beyond.</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mlaboratory.tech/2018/07/10/Android_JetPack-Lifecycles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T.M. Ma">
      <meta itemprop="description" content="just some notes">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17079743?v=3&s=466">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Timmy Ma">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/10/Android_JetPack-Lifecycles/" itemprop="url">
                  Android JetPack - Lifecycles
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-10 18:26:43 / 修改时间：17:06:29" itemprop="dateCreated datePublished" datetime="2018-07-10T18:26:43+08:00">2018-07-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android-JetPack/" itemprop="url" rel="index"><span itemprop="name">Android JetPack</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>管理 activity 和 fragment 的生命周期<br>参看 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="external">https://developer.android.com/topic/libraries/architecture/lifecycle</a>  </p>
<h1 id="使用生命周期感知组件来处理生命周期"><a href="#使用生命周期感知组件来处理生命周期" class="headerlink" title="使用生命周期感知组件来处理生命周期"></a>使用生命周期感知组件来处理生命周期</h1><p>生命周期感知组件执行操作来响应另一个组件（例如 Activity 或 Fragment ）的生命周期变更。这些组件可以帮你写出更易于组织更轻量级更易于维护的代码。<br>一种常见的模式就是在 Activity 和 Fragment 的生命周期方法中实现相关的操作。但只这种模式会导致代码组织不良和各种错误。通过使用生命周期感知组件，你可以将组件代码移出生命周期的方法，并且放到组件当中去。<br><code>android.arch.lifecycle</code> 包提供了类和借口，可以让你够贱生命周期感知组件，这些组件可以根据 Activity 和 Fragment 的当前生命周期状态自动调节其行为。<br>Android 框架中定义的大多数的应用程序组件都附加了生命周期，生命周期由操作系统或者进程中运行的框架代码管理。他们是 Android 工作原理的核心，你的 APP 必须尊重它们。不这样做的话可能会触发内存泄漏甚至应用程序崩溃。<br>想象我们有一个 Activity 显示当前的位置信息。一个最普通的实现大概应该是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// connect to system location service</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// disconnect from system location service</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</div><div class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</div><div class="line">            <span class="comment">// update UI</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        myLocationListener.start();</div><div class="line">        <span class="comment">// manage other components that need to respond</span></div><div class="line">        <span class="comment">// to the activity lifecycle</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        myLocationListener.stop();</div><div class="line">        <span class="comment">// manage other components that need to respond</span></div><div class="line">        <span class="comment">// to the activity lifecycle</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即使这个例子看起来没什么问题，但在真实的应用程序中，到最后会有很多的调用来管理 UI 和其他组件一相应生命周期的当前状态。管理多个组件需要在生命周期方法中放置大量代码，例如 <code>onStart()</code> 和 <code>onStop()</code> ，这样会越来越难维护。<br>此外，没有百分之百的保证组件能在 Activity 或者 Fragment 停止之前完成启动。尤其是在我们需要执行长时间运行的操作的时候，例如在 <code>onStart()</code> 中进行某些配置检查。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</div><div class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</div><div class="line">            <span class="comment">// update UI</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        Util.checkUserStatus(result -&gt; &#123;</div><div class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></div><div class="line">            <span class="keyword">if</span> (result) &#123;</div><div class="line">                myLocationListener.start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        myLocationListener.stop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>android.arch.lifecycle</code> 包提供了相应的类和接口来帮助你以弹性和隔离的方式解决这些问题。  </p>
<h1 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h1><p><code>LifeCycle</code> 类持有着组件的生命周期状态信息，并允许其他对象订阅状态。<br><code>LifeCycle</code> 主要使用两个枚举来跟踪其关联的组件的生命周期状态。  </p>
<ul>
<li><p>Event<br>从框架和 <code>Lifecycle</code> 类调度的生命周期事件。这些时间映射到 <code>Activity</code> 和 <code>Fragment</code> 的生命周期方法上。  </p>
</li>
<li><p>State<br><code>Lifecycle</code> 对象跟踪的组件的当前状态。  </p>
</li>
</ul>
<p><img src="https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png" alt=""><br>将 <code>state</code> 看作图形的节点，将 <code>event</code> 看作节点之间的连线。  </p>
<p>一个类可以通过给它的方法添加注解来监听组建的生命周期状态。然后你可以通过点用 <code>LifeCycle</code> 类的 <code>addObserver()</code> 方法并传递观察者的示例来添加观察者，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</div><div class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnectListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">myLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> MyObserver());</div></pre></td></tr></table></figure></p>
<p>上示示例中， <code>myLifecycleOwner</code> 对象实现了 <code>LifecyclerOwner</code> 接口</p>
<h1 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h1><p><code>LifecycleOwner</code> 是一个具有单一方法的接口，用来表示这个类具有生命周期。它只有一个方法， <code>getLifecycle()</code> 。如果你想要管理整个应用进程的生命周期，请看 <code>ProcessLifecycleOwner</code> 。<br>这个接口从各个类（如 <code>AppCompatActivity</code> 或者 <code>Fragment</code> ）中抽象出生命周期的所有关系，允许编写可以跟其一同工作的组件。任何自定义的应用程序类都可以实现 <code>LifecycleOwner</code> 接口。<br>实现了 <code>LifecycleObserver</code> 的组件可以与实现了 <code>LifecycleOwner</code> 的组件无缝合作，因为 owner 可以提供生命周期， observer 可以观察生命周期。<br>就刚才的位置跟踪的例子而言，我们可以让 <code>MyLocationListener</code> 类实现 <code>LifecycleObserver</code> ，然后在 Activity 的 <code>onCreate()</code> 方法中初始化。这样做可以让 <code>MyLocationListener</code> 类自给自足，也就是相应生命周期状态变化的逻辑在 <code>MyLocationListener</code> 中而不是在 Activity 中声明。使各个组件存储自己的逻辑似的 Activity 和 Fragment 的逻辑更易于管理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</div><div class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</div><div class="line">            <span class="comment">// update UI</span></div><div class="line">        &#125;);</div><div class="line">        Util.checkUserStatus(result -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (result) &#123;</div><div class="line">                myLocationListener.enable();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个常见的用例是，如果 <code>Lifecycle</code> 现在处于一个不合适的状态的时候，应该避免调用其回调。例如，如果回调在 Activity 保存状态后尝试执行 Fragment 事务，就会触发崩溃 ，因此我们永远也不想执行这些回调。<br>为了简化用例， <code>Lifecycle</code> 类允许其他对象查询当前的状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (enabled) &#123;</div><div class="line">           <span class="comment">// connect</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</div><div class="line">        enabled = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</div><div class="line">            <span class="comment">// connect if not connected</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// disconnect if connected</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这样的实现，我们的 <code>LocationListener</code> 类可以完全识别生命周期。如果我们需要在别的 Activity 或者 Fragment 里面使用 <code>LocationListener</code> ， 我们只需要实力化它就好了。所有的设置和写在操作都有类本身管理。<br>如果库提供了需要使用 Android 生命周期的类，我们建议你使用生命周期感知组件，你的继承库会轻松的集成这些组件而无需在客户端进行生命周期管理。  </p>
<h2 id="Implementing-a-custom-LifecycleOwner"><a href="#Implementing-a-custom-LifecycleOwner" class="headerlink" title="Implementing a custom LifecycleOwner"></a>Implementing a custom LifecycleOwner</h2><p>在 <code>Support Library 26.1.0</code> 及之后版本的 Fragment 和 Activity 都已经实现了 <code>LifecycleOwner</code> 接口。<br>如果你有一个自定义类需要实现 <code>LifecyclerOwner</code> ，你可以使用 <code>LifecycleRegistry</code> ，但是你需要在类中手动转发事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</div><div class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mLifecycleRegistry;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Best-practices-for-lifecycle-aware-components"><a href="#Best-practices-for-lifecycle-aware-components" class="headerlink" title="Best practices for lifecycle-aware components"></a>Best practices for lifecycle-aware components</h1><ul>
<li>保持 UI controller（ Activity 或者 Fragment ） 尽可能的简洁，他们不应该自己获取数据，使用 <code>ViewModel</code> 去做，并贯彻一个 <code>LiveData</code> 对象来将变更反映到 UI 上。  </li>
<li>尝试编写数据驱动的 UI ， 其中 UI controller 负责在数据更改时更新 UI ，或是将用户的交互反馈给 <code>ViewModel</code></li>
<li>将数据逻辑放在 <code>ViewModel</code> <code>类中。ViewModel</code> 应该充当 UI controller 和应用其余部分之间的桥梁。但是要小心， <code>ViewModel</code> 不负责获取数据（从网络获取、从 DB 获取），相反， <code>ViewModel</code> 应调用适当的组件来获取数据，然后将结果提供回 UI 控制器。  </li>
<li>使用数据绑定库来维护视图和 UI controller 的干净代码。这可以是视图更具声明性，并最大限度的减少 Activity 和 Fragment 中编写所需的更新代码。如果您更习惯使用 Java 来写，请使用 <code>ButtterKnife</code> 这样的库莱尽可能避免模板代码并且具有更好的抽象。</li>
<li>如果你的 UI 很复杂，请考虑创建一个 <code>Presenter</code> 类来处理 UI 的修改。这可能是一个艰巨的任务，但是这可以使你的 UI 组件更容易测试。  </li>
<li>避免在 <code>ViewModel</code> 中引用 <code>View</code> 或者 <code>Activity</code> context ，如果 <code>ViewModel</code> 的生命周期超过了 Activity 的话，这会造成 Activity 泄漏不能被 GC 正确处理。</li>
</ul>
<h1 id="Use-cases-for-lifecycle-aware-components"><a href="#Use-cases-for-lifecycle-aware-components" class="headerlink" title="Use cases for lifecycle-aware components"></a>Use cases for lifecycle-aware components</h1><p>生命周期感知组件可以使你在各种情况下更轻松的管理生命周期，一些例子：</p>
<ul>
<li>在高精度和低精度位置更新服务之间切换。使用生命周期感知组件可以在您的位置应用程序课间时使用高精度位置更新，在应用程序处于后台的时候切换到低精度位置更新。 <code>LiveData</code> 是一个生命周期感知组建，允许你的应用在用户位置更改的时候自动更新 UI。</li>
<li>开始和停止视频缓冲。是用生命周期感知组建尽快启动视频缓冲，但是直到应用程序完全启动的时候才开始播放。你还可以使用生命周期感知组件在应用程序终止的时候终止缓冲。</li>
<li>开始和停止网络连接。使用生命周期感知组件在应用程序在前台的时候启用网络数据并且实时更新，并在应用程序进入后台之后自动暂停。</li>
<li>暂用和恢复 animated drawables 。当应用程序在后台时，使用生命周期感知组件处理暂停 animated drawable ，并在应用程序位于前台后恢复。</li>
</ul>
<h1 id="Handling-on-stop-events"><a href="#Handling-on-stop-events" class="headerlink" title="Handling on stop events"></a>Handling on stop events</h1><p>对于 <code>AppCompatActivity</code> 和 <code>Fragment</code> 来说，在 <code>AppCompatActivity</code> 和 <code>Fragment</code> 的 <code>onSaveInstanceState()</code> 方法被调用的时候， <code>LifeCycle</code> 的 state 会变为 <code>CREATED</code> ，并且会触发 <code>ON_STOP</code> 事件。  </p>
<p>当 <code>Fragment</code> 和 <code>AppCompatActivity</code> 的状态通过 <code>onSaveInstanceState()</code> 保存了的时候，我们会认为直到 <code>ON_START</code> 之前 UI 都是不可变的了。在状态保存后企图修改 UI 会导致应用程序的导航状态不一致，这就为什么 <code>FragmentManager</code> 在保存状态后执行 <code>FragmentTransaction</code> 时会抛出异常了。  </p>
<p>在如果观察者的生命周期还没有到 <code>STARTED</code> 的时候， <code>LiveData</code> 会通过禁止其调用观察者来避免上述情况发生。实际上，在他决定调用观察者之前，会调用 <code>isAtLeast()</code> 。  </p>
<p>不幸的是， <code>AppCompatActivity</code> 的 <code>onStop()</code> 方法在 <code>onSaveInstanceState()</code> 之后调用，这样会导致有一小段时间 UI 状态不允许修改但是 <code>Lifecycle</code> 的状态还没有从 <code>STARTED</code> 变成 <code>CREATED</code> 。  </p>
<p>为了解决上述问题， <code>beta2</code> 版本以及更低版本的 <code>Lifecycle</code> 类将上述情况的状态标记为 <code>CREATED</code> ，即使还没分发 <code>ON_STOP</code> 的事件。这样以便于获取的状态的代码能够在 <code>onStop()</code> 被调用之前未发出 <code>ON_STOP</code> 事件的情况下正常工作。</p>
<p>不幸的是，这个解决方案有两个主要的问题：</p>
<ul>
<li>在 <code>API 23</code> 以及更低的情况下， Android 系统会在 Activity 被另一个 Activity 部分遮挡的情况下去保存状态。换句话说，就是 Android 系统会在不调用 onStop() 的情况下去调用 <code>onSaveInstanceState()</code> 。这会导致在很长的一段时间内，即使无法修改 UI 状态，观察者仍然会认为生命周期处于活跃状态。  </li>
<li>任何想要实现 <code>LiveData</code> 类类似行为的类都要去重新实现一边 <code>LifeCycle beta2</code> 的补丁代码。  </li>
</ul>
<blockquote>
<p>为了简化流程并且提供更好的旧版本的兼容性，从 <code>1.0.0-rc1</code> 版本开始， <code>LifeCycle</code> 对象会在 <code>onSaveInstanceState()</code> 调用之后被标记为 <code>CREATED</code> ，并且下发 <code>ON_STOP</code> 事件，不再等待 <code>onStop()</code> 调用。虽然这可能不太影响你的代码，但是你需要注意到它与 <code>API 26</code> 以及更低版本的 Activity 的调用顺序不匹配。 </p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mlaboratory.tech/2018/07/09/Android_Jetpack-Data_Binding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T.M. Ma">
      <meta itemprop="description" content="just some notes">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17079743?v=3&s=466">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Timmy Ma">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/Android_Jetpack-Data_Binding/" itemprop="url">
                  Android Jetpack - Data Binding
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-09 15:18:00 / 修改时间：18:28:55" itemprop="dateCreated datePublished" datetime="2018-07-09T15:18:00+08:00">2018-07-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android-JetPack/" itemprop="url" rel="index"><span itemprop="name">Android JetPack</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以声明的方式将 observable 数据绑定到 UI 元素<br>参考 <a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="external">https://developer.android.com/topic/libraries/data-binding/</a></p>
<h1 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h1><p>添加 dataBinding 元素到项目中 app moudule 的 build.gradle 文件中：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    dataBinding &#123;</div><div class="line">        enabled = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Layouts-amp-binding-expressions"><a href="#Layouts-amp-binding-expressions" class="headerlink" title="Layouts &amp; binding expressions"></a>Layouts &amp; binding expressions</h1><p>使用 Databinding 的 layout 文件与正常的略微有些不同，它使用了 <code>layout</code> 作为 root tag ，里面包裹着 <code>data</code> 元素和真正的 <code>view</code> 元素：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中data 标签包裹着的变量 “<code>user</code>“ 即为当前 layout 所使用的属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>在使用该属性的表达式中，使用 “<code>@{}</code>“ 的语法来表示引用，这里， <code>TextView</code> 的文字被设置为 <code>user</code> 的 <code>firstName</code> 属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span> </span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">ndroid:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span> /&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>表达式应该尽可能的简洁，因为他们不能被单元测试。如果想要简化复杂的表达式，可以使用 Binding adapters。  </p>
</blockquote>
<h2 id="Data-object"><a href="#Data-object" class="headerlink" title="Data object"></a>Data object</h2><p>先来假设有一个普通的 Java 对象 – <code>User</code> ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String firstName;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String lastName;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这种对象的数据永远不会变，这些数据通常都会被读取一次之后也不会被更改，对象也可以遵循公约定义一些 get 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从数据绑定的角度来看，上面这两种类的写法是等价的，第一种写法的情况下，<code>android:text</code> 中的 <code>@{user.firstName}</code> 表达式会直接读取该类的 <code>firstName</code> 属性，第二种写法则是直接调用 <code>getFirstName()</code> 方法。另外，如果有 <code>firstName()</code> 方法也会被调用。  </p>
<h2 id="Binding-data"><a href="#Binding-data" class="headerlink" title="Binding data"></a>Binding data</h2><p>Binding class 根据 <code>layout</code> 文件自动生成，默认情况下，绑定类的名字根据 layout 文件的名字反向生成并追加 <em>Binding</em> 后缀。上节的 <code>layout</code> 文件名字为 <code>activity_main.xml</code> ，对应的转换后的类名为 <code>MainActivityBinding</code> 。绑定类持有着所有的有关布局信息的绑定，并且知道如何根据绑定的表达式赋值。推荐的做法是在 inflafe layout 的同时创建绑定，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    MainActivityBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>,  R.layout.activity_main);</div><div class="line">    User user = <span class="keyword">new</span> User(<span class="string">"Test"</span>, <span class="string">"User"</span>);</div><div class="line">    binding.setUser(user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>gradle 插件版本 3.1.3，亲测 <code>activity_main.xml</code> 生成的类名为 <code>ActivityMainBinding</code> ，并没有反转</p>
</blockquote>
<p>在运行时，程序在 UI 上显示了 Test 。另外，也可以通过 LayoutInflater 来获取 view ，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());</div><div class="line">View view = binding.getRoot();</div></pre></td></tr></table></figure></p>
<p>如果在 <code>Fragment</code> ， <code>ListView</code> ， <code>RecyclerView</code> adapter 中使用数据绑定的话，应该使用绑定类的 <code>inflate()</code> 方法，或是 <code>DataBindingUtil</code> ，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="keyword">false</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="一般功能"><a href="#一般功能" class="headerlink" title="一般功能"></a>一般功能</h3><p>你可以使用下列操作符和关键字：  </p>
<ul>
<li>数学表达式 <code>+ - / * %</code></li>
<li>字符串拼接 <code>+</code></li>
<li>逻辑操作符 <code>&amp;&amp; ||</code></li>
<li>二进制运算 <code>&amp; | ^</code></li>
<li>一元运算 <code>+ - ？ ！</code></li>
<li>位移 <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li>
<li>比较 <code>== &gt; &lt; &gt;= &lt;=</code></li>
<li><code>instanceof</code></li>
<li>分组 <code>()</code></li>
<li>字 <code>字符，字符串，数字，null</code></li>
<li>类型转换</li>
<li>方法调用</li>
<li>属性访问</li>
<li>数组访问 <code>[]</code></li>
<li>三元运算符号 <code>?:</code></li>
</ul>
<p>示例如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;android:text="@&#123;String.valueOf(index + 1)&#125;"/&gt;</div><div class="line">&lt;android:visibility="@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;"/&gt;</div><div class="line">&lt;android:transitionName="@&#123;`image_` + id&#125;"/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="不支持的操作"><a href="#不支持的操作" class="headerlink" title="不支持的操作"></a>不支持的操作</h3><ul>
<li><code>this</code></li>
<li><code>super</code></li>
<li><code>new</code></li>
<li>显式泛型调用</li>
</ul>
<h3 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h3><p>空合并操作符 <code>??</code> 会在左边表达式为 <code>null</code> 的情况下返回右边表达式的值<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;user.displayName</span> ?? <span class="attr">user.lastName</span>&#125;"/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;user.displayName</span> != <span class="string">null</span> ? <span class="attr">user.displayName</span> <span class="attr">:</span> <span class="attr">user.lastName</span>&#125;"/&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h3><p>表达式可以直接引用同名的属性、get 方法和 <code>ObservableField</code> 对象：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;user.lastName&#125;"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="避免空指针异常"><a href="#避免空指针异常" class="headerlink" title="避免空指针异常"></a>避免空指针异常</h3><p>生成的绑定类会自动检查 <code>null</code> 并且避免空指针异常，比如说表达式 <code>@{user.name}</code> 中，如果 <code>user</code> 为空， <code>user.name</code> 会被默认分配 <code>null</code> ，如果是 <code>user.age</code> ，年龄为 <code>int</code> 类型，数据绑定会返回默认值 <code>0</code>。  </p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>常用的集合，诸如 <code>arrays</code> ， <code>lists</code> ， <code>sparse lists</code> 和 <code>maps</code> 都可以用 <code>[]</code> 来访问<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.util.SparseArray"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.Map"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.List"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">type</span>=<span class="string">"List&amp;lt;String&amp;gt;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"sparse"</span> <span class="attr">type</span>=<span class="string">"SparseArray&amp;lt;String&amp;gt;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"map"</span> <span class="attr">type</span>=<span class="string">"Map&amp;lt;String, String&amp;gt;"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"index"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"key"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;list[index]&#125;"</span>/&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;sparse[index]&#125;"</span>/&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;map[key]&#125;"</span>/&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;map.key&#125;"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="字符串文字"><a href="#字符串文字" class="headerlink" title="字符串文字"></a>字符串文字</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android:text='@&#123;map["firstName"]&#125;'</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;map[`firstName`]&#125;"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h3 id="资源引用"><a href="#资源引用" class="headerlink" title="资源引用"></a>资源引用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android:padding="@&#123;large?</span> @<span class="attr">dimen</span>/<span class="attr">largePadding</span> <span class="attr">:</span> @<span class="attr">dimen</span>/<span class="attr">smallPadding</span>&#125;"/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;@string</span>/<span class="attr">nameFormat</span>(<span class="attr">firstName</span>, <span class="attr">lastName</span>)&#125;"/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android:text="@&#123;@plurals</span>/<span class="attr">banana</span>(<span class="attr">bananaCount</span>)&#125;"/&gt;</span></div></pre></td></tr></table></figure>
<p>有些资源需要更详细的声明，见下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>通常引用</th>
<th>表达式引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String[]</td>
<td>@array</td>
<td>@stringArray</td>
</tr>
<tr>
<td>int[]</td>
<td>@array</td>
<td>@intArray</td>
</tr>
<tr>
<td>TypedArray</td>
<td>@array</td>
<td>@typedArray</td>
</tr>
<tr>
<td>Animator</td>
<td>@animator</td>
<td>@animator</td>
</tr>
<tr>
<td>StateListAnimator</td>
<td>@animator</td>
<td>@stateListAnimator</td>
</tr>
<tr>
<td>corlor int</td>
<td>@color</td>
<td>@color</td>
</tr>
<tr>
<td>ColorStateList</td>
<td>@color</td>
<td>@ColorStateList</td>
</tr>
</tbody>
</table>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>数据绑定允许通过编写表达式来处理 view 分发的事件（例如 <code>onClick()</code>）。事件参数的名字由监听回调的方法名决定，当然也有少数例外：  </p>
<table>
<thead>
<tr>
<th>类</th>
<th>监听回调 setter</th>
<th>参数写法  </th>
</tr>
</thead>
<tbody>
<tr>
<td>SearchView</td>
<td>setOnSearchClickListener(View.OnClickListener)</td>
<td>android:onSearchClick  </td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomInClickListener(View.OnClickListener)</td>
<td>android:onZoomIn  </td>
</tr>
<tr>
<td>ZoomControls</td>
<td>setOnZoomOutClickListener(View.OnClickListener)</td>
<td>android:onZoomOut  </td>
</tr>
</tbody>
</table>
<p>你可以使用两种机制来处理事件：</p>
<ul>
<li>方法引用：在你的表达式中可以直接调用符合监听函数签名的方法（方法名、参数、返回值类型一致），当表达式指向了一个方法引用的时候，数据绑定自动将方法引用和诉诸对象包裹在监听中，并将监听设置给目标 view ，如果表达式等于 null ， 数据绑定不会创建监听，反之会将监听设 null 。</li>
<li>监听绑定：即为事件触发时调用的 lambda 表达式。数据绑定总是会创建监听并且会 set 给 view 。当事件分发的时候，监听会直接调用 lambda 表达式。</li>
</ul>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>时间可以直接绑定到相应的处理方法上，与 android:onClick 可以绑定 activity 中的一个方法一样。根使用 View 的 onClick 参数相比，方法引用表达式的一个主要的优点就是他是在编译时进行处理的，如果方法不存在或者方法签名不正确的话我们在编译的时候就能发现。<br>方法引用与监听绑定的主要区别就在于，实际的监听实现是在数据绑定的时候就创建了，而不是在事件出发的时候。如果你更倾向于在事件发生的时候调用表达式，你应该使用监听绑定。<br>要将事件分配给其处理程序，使用一个普通的绑定表达式，其值为要调用的方法的名称：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlers</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickFriend</span><span class="params">(View view)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>绑定表达式可以给 view 设置点击监听调用 onClickFriend() 方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"handlers"</span> <span class="attr">type</span>=<span class="string">"com.example.MyHandlers"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></div><div class="line">           <span class="attr">android:onClick</span>=<span class="string">"@&#123;handlers::onClickFriend&#125;"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上述代码中的 <code>onClickFriend()</code> 方法的签名必须跟 <code>View.OnClickListener.onClick()</code> 方法一致  </p>
<h3 id="监听绑定"><a href="#监听绑定" class="headerlink" title="监听绑定"></a>监听绑定</h3><p>监听绑定是事件发生的时候执行的绑定表达式。与方法引用类似，但是可以让你执行任意的数据绑定表达式。这个功能在 Gradle 2.0 以后的对应的 Android Gradle Plugin 版本中可用。</p>
<p>在方法引用里，方法的参数和事件监听的回调参数必须一致。在使用监听绑定的时候，只需要确保返回值一致就行了。假设 <code>Presenter</code> 类有一个 <code>onSaveClick()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(Task task)</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将事件绑定到 <code>onSaveClick</code> 方法上：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"task"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Task"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"presenter"</span> <span class="attr">type</span>=<span class="string">"com.android.example.Presenter"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></div><div class="line">        <span class="attr">android:onClick</span>=<span class="string">"@&#123;() -&gt; presenter.onSaveClick(task)&#125;"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当回调方法被用在了表达式上后，数据绑定类自动创建必要的监听并且注册到该事件上。当 view 分发事件的时候，数据绑定会直接调用给定的表达式。与常规的表达式一样，在调用这些监听表达式时候，你依旧可以获得线程安全和 null 保护。<br>上面的例子中，我们没有给 <code>onSaveClick()</code> 方法定义 <code>onClick(View)</code> 中的 view 参数。监听绑定提供两种监听参数：要么忽略所有参数，要么声明所有的参数。如果你更倾向于声明所有参数，你就可以在你的表达式中使用他们了（就是 lambda 表达式的写法）。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 你声明了 onClick 回调方法的所有参数（参数只有 view），但是你没有使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">android:onClick="@&#123;(view)</span> <span class="attr">-</span>&gt;</span> presenter.onSaveClick(task)&#125;"/&gt;</div></pre></td></tr></table></figure></p>
<p>假如你想要在表达式中使用声明了的参数：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android:onClick="@&#123;(theViewINamed)</span> <span class="attr">-</span>&gt;</span> presenter.onSaveClick(theViewINamed, task)&#125;"/&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveClick</span><span class="params">(View view, Task task)</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然你也可以使用带有多个参数的 lambda 表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletedChanged</span><span class="params">(Task task, <span class="keyword">boolean</span> completed)</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 即使在后面的表达式中只用了一个参数，也必须声明 onCheckedChanged 方法的所有参数</div><div class="line"><span class="tag">&lt;<span class="name">CheckBox</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span> <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></div><div class="line">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;"</span> /&gt;</div></pre></td></tr></table></figure>
<p>如果监听的事件回调函数有返回值的话，你的表达式也必须返回相同的类型。如果表达式因为 null 保护而无法被调用的话，数据绑定会默认但会该类型的默认值，引用类型为 <code>null</code> ， <code>int</code> 为 <code>0</code> ， <code>boolean</code> 为 <code>false</code> 。<br>如果你需要在表达式中使用断言（例如三目运算符），你可以使用 void 作为占位：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android:onClick="@&#123;(v)</span> <span class="attr">-</span>&gt;</span> v.isVisible() ? doSomething() : void&#125;"/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="要避免复杂的监听"><a href="#要避免复杂的监听" class="headerlink" title="要避免复杂的监听"></a>要避免复杂的监听</h4><p>监听表达式非常强力，可以使你的代码简单易读。另一方面，包含复杂的表达式的监听可能是你的 layout 难于阅读和维护，这些表达式应该像 UI 向你自己的代码的监听传值一样简单。你应该在从侦听器表达式调用的回调方法中实现业务逻辑。  </p>
<h2 id="Imports-，variables-和-includes"><a href="#Imports-，variables-和-includes" class="headerlink" title="Imports ，variables 和 includes"></a>Imports ，variables 和 includes</h2><p>数据绑定库也提供诸如 imports ， variables ， includes 的功能。Imports 可以让在布局文件中引用类更简单。Variables 可以使你描述细节并用到表达式中。Includes 可以让你复用复杂的布局。</p>
<h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>可以引用类。例如导入了 android.view.View 类就可以使用 View.VISIABLE 和 View.GONE 了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:visibility</span>=<span class="string">"@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>当导入的类名有冲突的时候，我们可以给类指定别名：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 此时 View 指代 android.view.View ，使用 Vista 指代 com.example.real.estate.View --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.view.View"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.real.estate.View"</span></span></div><div class="line">    <span class="attr">alias</span>=<span class="string">"Vista"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="导入其他类"><a href="#导入其他类" class="headerlink" title="导入其他类"></a>导入其他类</h4><p>导入的类可以作为其他类型的引用，下面这个例子展示了 <code>User</code> 类被 <code>List</code> 类用来做类型参数的情况：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"java.util.List"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"userList"</span> <span class="attr">type</span>=<span class="string">"List&amp;lt;User&amp;gt;"</span>/&gt;</span> // 没错，<span class="tag">&lt;&gt;</span>要转义</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>也可以用导入的类进行类型转换：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@&#123;((User)(user.connection)).lastName&#125;"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>导入类可以直接调用静态方法和字段，下面的例子引用了 <code>MyStringUtils</code> 类的静态方法 <code>capitalize()</code> :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.MyStringUtils"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">"@&#123;MyStringUtils.capitalize(user.lastName)&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>你可以在 <code>data</code> 标签中使用多个 <code>variable</code> 元素。每个 <code>variable</code> 都描述了一个可以在 layout 表达式中能用到的属性。下面的代码声明了 <code>user</code> ， <code>image</code> ， <code>note</code> 变量：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.graphics.drawable.Drawable"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">type</span>=<span class="string">"Drawable"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>变量的类型会在编译时进行检查，因此如果变量实现了 <code>Observable</code> 或者是一个 <code>Observable Colloction</code> 的话，那他就会是可反射的。如果变量是一个基本类或者是一个没实现 <code>Observable</code> 的接口，那么这个变量就不是可观察的。<br>当布局文件根据不同配置发生改变的时候，变量时合并了的。这些布局文件中的变量绝对不可以有冲突。<br>生成的绑定类有对应每一个变量的 getter 和 setter ，直到 setter 被调用之前，变量都会使用其对应类型的默认值。<br>一个叫做 <code>context</code> 的特殊的变量被自动生成，以用来在表达式中使用。 <code>context</code> 的值相当于 root view 调用 <code>getContext()</code> 的返的 <code>Context</code> 对象。 <code>context</code> 会被显示声明的相同名称的变量所覆盖。  </p>
<h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><p>变量可以通过在 <code>include</code> 标签中使用 app 的命名空间并设置其对应的变量名来将变量传入到 include 的 layout 中。示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></div><div class="line">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></div><div class="line">           <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>数据绑定不支持 <code>include</code> 作为 <code>merge</code> 元素的直接子元素。例如，以下的布局是不支持的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">        <span class="attr">xmlns:bind</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">merge</span>&gt;</span><span class="comment">&lt;!-- Doesn't work --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/name"</span></span></div><div class="line">            <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/contact"</span></span></div><div class="line">            <span class="attr">bind:user</span>=<span class="string">"@&#123;user&#125;"</span>/&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="Work-with-observable-data-objects"><a href="#Work-with-observable-data-objects" class="headerlink" title="Work with observable data objects"></a>Work with observable data objects</h1><p>可观察性（Observability）代表着在一个对象可以通知其他对象他的数据变化的能力。数据绑定库可以让你将对象、字段、集合变为可观察的（observable）。<br>任何普通的 Java 类都可以用来做数据绑定，但是变更这个对象的时候不会自动通知 UI 更新数据。数据绑定可以是你的对象在数据变化的时候通知其他对象，也就是通知他的监听器。有三种 observable 的类型，对象、字段和集合。<br>当以上任意一种 observable 的数据被绑定到 UI 上后，当其数据发生变化时，UI 也会自动更新。  </p>
<h2 id="Observable-fields"><a href="#Observable-fields" class="headerlink" title="Observable fields"></a>Observable fields</h2><p>创建实现了 <code>Observable</code> 接口的类需要做好些工作，这对于你那些只有几个字段的类来说并不友好。这种情况下，你可以使用通用的 <code>Observable</code> 类，下联就列举了基本类型的 observable 版本：</p>
<ul>
<li>ObservableBoolean</li>
<li>ObservableByte</li>
<li>ObservableChar</li>
<li>ObservableShort</li>
<li>ObservableInt</li>
<li>ObservableLong</li>
<li>ObservableFloat</li>
<li>ObservableDouble</li>
<li>ObservableParcelable</li>
</ul>
<p><code>Observable</code> 字段 自带了包含有一个字段的 observable 对象。原始版本在访问操作期间可以避免装箱和拆箱。为了利用这个机制，我们在 Java 语言中将其用 <code>public final</code> 修饰（为了保持其引用不变），在 Kotlin 中使用 <code>val</code> 修饰（只读）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 <code>set()</code> <code>get()</code> 方法以访问其中的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user.firstName.set(<span class="string">"Google"</span>);</div><div class="line"><span class="keyword">int</span> age = user.age.get();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Android Studio 3.1 及更高版本会建议你用 LiveData 来替换 observable 字段，详见 LiveData 文档</p>
</blockquote>
<h3 id="Observable-collections"><a href="#Observable-collections" class="headerlink" title="Observable collections"></a>Observable collections</h3><p>有些 app 使用动态的结构来保存数据。<code>Observable collections</code> 允许通过 key <code>来访问这些数据结构。ObservableArrayMap</code> 类在 key 是引用类型的时候就很有帮助，例如 <code>String</code> ，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ObservableArrayMap&lt;String, Object&gt; user = <span class="keyword">new</span> ObservableArrayMap&lt;&gt;();</div><div class="line">user.put(<span class="string">"firstName"</span>, <span class="string">"Google"</span>);</div><div class="line">user.put(<span class="string">"lastName"</span>, <span class="string">"Inc."</span>);</div><div class="line">user.put(<span class="string">"age"</span>, <span class="number">17</span>);</div></pre></td></tr></table></figure></p>
<p>在 layout 文件中，这个 map 可以用 <code>String</code> 类型的 key 来访问：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableMap"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableMap&lt;String, Object&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"@&#123;String.valueOf(1 + (Integer)user.age)&#125;"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p><code>ObservableArrayList</code> 用于 key 是一个 <code>Integer</code> 的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ObservableArrayList&lt;Object&gt; user = <span class="keyword">new</span> ObservableArrayList&lt;&gt;();</div><div class="line">user.add(<span class="string">"Google"</span>);</div><div class="line">user.add(<span class="string">"Inc."</span>);</div><div class="line">user.add(<span class="number">17</span>);</div></pre></td></tr></table></figure></p>
<p>在 layout 文件中即可用 index 来访问数据：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableList"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.my.app.Fields"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableList&lt;Object&gt;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">…</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">'@&#123;user[Fields.LAST_NAME]&#125;'</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">'@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;'</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Observable-objects"><a href="#Observable-objects" class="headerlink" title="Observable objects"></a>Observable objects</h2><p>实现了 <code>Observable</code> 接口的类可以让注册了的监听起们在数据变化的时候获得通知。<br><code>Observable</code> 接口有添加和移除监听器的机制，但是你必须决定什么时候去发通知。为了使开发工作更简单，数据绑定库提供了已经实现了监听器注册机制的 <code>BaseObservable</code> 类。实现 <code>BaseObservable</code> 的类负责在数据变化的时候发出通知。通过给 getter 方法注解 <code>Bindable</code> 、然后在 setter 方法中调用 <code>notifyPropertyChanged()</code> 方法来实现，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String firstName;</div><div class="line">    <span class="keyword">private</span> String lastName;</div><div class="line"></div><div class="line">    <span class="meta">@Bindable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bindable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        notifyPropertyChanged(BR.firstName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">        notifyPropertyChanged(BR.lastName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数据绑定在对应的 module 中生成一个叫做 <code>BR</code> 的类（类似于 <code>R</code> ），其中包含了数据绑定的资源的 ID <code>。Bindable</code> 注解在编译时在 <code>BR</code> 类中生成一个实体类。如果数据类的类型是不可变的，则可以使用 <code>PropertyChangeRegistry</code> 对象实现 <code>Observable</code> 接口，以高效的注册和通知监听器。  </p>
<h1 id="Generated-binding-classes"><a href="#Generated-binding-classes" class="headerlink" title="Generated binding classes"></a>Generated binding classes</h1><p>数据绑定库默认会生成类来访问 layout 里面的变量和视图。下面会展示如何创建和自定义绑定类。<br>生成的绑定类将 layout 中的变量和视图联系了起来。绑定类的包名和类名都可以自定义。所有的绑定类都继承于 <code>ViewDataBinding</code> 类。<br>每一个 layout 文件都会生成一个对应的绑定类。默认情况下，类名基于 layout 文件的名称进行驼峰命名并追加 <code>Binding</code> 后缀。上文的 layout 文件名为 <code>activity_main.xml</code> ，生成的类名即为 <code>ActivityMainBinding</code> 。这个类持有着所有的布局中视图信息，可以根据绑定的表达式给视图设置属性。  </p>
<h2 id="Create-a-binding-object"><a href="#Create-a-binding-object" class="headerlink" title="Create a binding object"></a>Create a binding object</h2><p>绑定类对象紧接着在填充布局之后被创建，以确保视图在绑定之前不会被修改。将绑定类对象绑定到 layout 最常用的方法就是使用绑定类的静态方法。你可以通过调用绑定类的静态方法 <code>inflate()</code> 来同时完成填充布局和视图绑定。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">  MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有一个 <code>inflate()</code> 的重载方法接收除了 <code>LayoutInflater</code> 之外的一个参数 – <code>ViewGroup</code> ，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(getLayoutInflater(), viewGroup, <span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p>如果布局已经通过其他形式 inflate 了，可以如下进行单独的绑定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</div></pre></td></tr></table></figure></p>
<p>有些情况下，绑定类的类型无法事先得知，可以用 <code>DataBindingUtil</code> 来创建绑定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);</div><div class="line">ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);</div></pre></td></tr></table></figure></p>
<p>如果你结合 <code>Fragment</code> ， <code>ListView</code> 或者 <code>RecyclerView</code> Adapter 使用数据绑定，你应该使用绑定类的 <code>inflate()</code> 方法，或者 <code>DataBindingUtil</code> 类，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, <span class="keyword">false</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, <span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<h2 id="带有-ID-的-View"><a href="#带有-ID-的-View" class="headerlink" title="带有 ID 的 View"></a>带有 ID 的 View</h2><p>数据绑定库在绑定类中为每个在 layout 中带有 ID 的 <code>View</code> 创建了 immutable 的字段。例如数据绑定库会创建名叫 <code>firstName</code> 和 <code>lastName</code> 的 <code>TextView</code> 字段，在生成的绑定类中可以看到他们是被 <code>final</code> 修饰的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span></div><div class="line">   <span class="attr">android:id</span>=<span class="string">"@+id/firstName"</span>/&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></div><div class="line">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></div><div class="line">  <span class="attr">android:id</span>=<span class="string">"@+id/lastName"</span>/&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>数据绑定库在同一个类中提取了带有 ID 的 view 。这个机制可比给每个 <code>View</code> 都调用 <code>findViewById()</code> 快多了。<br>不使用数据绑定的话 ID 看起来没什么意义，但是仍然在有些情况需要在代码中调用。  </p>
<h2 id="Variables-1"><a href="#Variables-1" class="headerlink" title="Variables"></a>Variables</h2><p>数据绑定库为在布局中声明了的变量提供了访问方法。在下面的示例中，为 <code>user</code> ， <code>image</code> 和 <code>note</code> 生成了对应的 getter 和 setter 方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.graphics.drawable.Drawable"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"image"</span> <span class="attr">type</span>=<span class="string">"Drawable"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="ViewStubs"><a href="#ViewStubs" class="headerlink" title="ViewStubs"></a>ViewStubs</h2><p>与正常的 <code>View</code> 对象不同， <code>ViewStub</code> 对象最开始是一个不可见的 view 。当他们被设为可见或者被明确调用了 <code>inflate()</code> 方法的时候，他们才将自己替换成即将被渲染的 view 。<br>因为 <code>ViewStub</code> 最终会在视图层次中消失，绑定对象中的 view 为了能被垃圾回收也需要销毁。因为 view 是 <code>final</code> 的， <code>ViewStubProxy</code> 对象会在生成的绑定类中替代 <code>ViewStub</code> ， 以此来在 <code>ViewStub</code> 存在的时候提供对 <code>ViewStub</code> 的访问，以及在 <code>ViewStub</code> inflate 之后提供对视图的访问。<br>当 inflate 另一个 layout 的时候，必须为新的布局建立绑定。因此， <code>ViewStubProxy</code> 必须监听 <code>ViewStub</code> 的 <code>OnInflateListener</code> ，并且在需要的时候建立绑定。由于在给定的时间内只能存在一个监听器， <code>ViewStubProxy</code> 允许你设置 <code>OnInflateListener</code> ， 并且在建立绑定之后得到回调。  </p>
<h2 id="Immediate-Binding"><a href="#Immediate-Binding" class="headerlink" title="Immediate Binding"></a>Immediate Binding</h2><p>当变量或者 observable 对象发生改变的时候，绑定会计划在下一帧之前生效。但是有些情况下需要立即进行绑定。要强制执行绑定，直接调用 <code>executePendingBindings()</code> 方法。  </p>
<h2 id="Advanced-Binding"><a href="#Advanced-Binding" class="headerlink" title="Advanced Binding"></a>Advanced Binding</h2><h3 id="Dynamic-Varaibles"><a href="#Dynamic-Varaibles" class="headerlink" title="Dynamic Varaibles"></a>Dynamic Varaibles</h3><p>有些情况下，指定的绑定类是未知的。举例来说， <code>RecyclerView.Adapter</code> 就不知到它该用何种绑定类（因为 Item Type 太多了），它得在调用 <code>onBindViewHolder()</code> 时分配绑定值。<br>在下面的例子里， <code>RecyclerView</code> 绑定的每一个的 layout 都对应着一个 item 变量。 <code>BindingHolder</code> 对象有一个 <code>getBinding()</code> 方法来返回基类 <code>ViewDataBinding</code> 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(BindingHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> T item = mItems.get(position);</div><div class="line">  holder.getBinding().setVariable(BR.item, item);</div><div class="line">  holder.getBinding().executePendingBindings();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Background-Thread"><a href="#Background-Thread" class="headerlink" title="Background Thread"></a>Background Thread</h2><p>只要你的数据对象不是集合类，你就可以随意的在后台线程更改你的数据。数据绑定会在调用期间本地化每一个变量以此来避免并发问题。  </p>
<h2 id="Custom-binding-class-names"><a href="#Custom-binding-class-names" class="headerlink" title="Custom binding class names"></a>Custom binding class names</h2><p>默认情况下，绑定类的名称是根据 layout 文件的文件名来决定的。生成的绑定类位于当前 module 包名下的 databinding 包中。  </p>
<p>绑定类可以通过 data 元素中的 class 参数来指定：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- module.package.name.databinding.ContactItem --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">"ContactItem"</span>&gt;</span></div><div class="line">    …</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- module.ppackage.name.ContactItem --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">".ContactItem"</span>&gt;</span></div><div class="line">    …</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- com.example.ContactItem --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">class</span>=<span class="string">"com.example.ContactItem"</span>&gt;</span></div><div class="line">    …</div><div class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="Binding-adapters"><a href="#Binding-adapters" class="headerlink" title="Binding adapters"></a>Binding adapters</h1><p>Binding adapters 负责对想要适当的值进行框架层面的调用。例如通过调用 <code>setText()</code> 方法设置一个合适的值，或是调用 <code>setOnClickListener()</code> 设置监听。<br>数据绑定允许你通过使用 binding adapters 来指定方法进行赋值，提供自定义的绑定逻辑，指定返回对象的类型。  </p>
<h2 id="Setting-attribute-values"><a href="#Setting-attribute-values" class="headerlink" title="Setting attribute values"></a>Setting attribute values</h2><p>无论绑定的值如何变化，生成的绑定类必须要借助绑定表达式对 view 调用一个 setter 方法。你可以让数据绑定库自定决定调用何种方法，或是指定方法，再或是提供逻辑来指定方法。  </p>
<h3 id="Automatic-method-selection"><a href="#Automatic-method-selection" class="headerlink" title="Automatic method selection"></a>Automatic method selection</h3><p>举个例子，如果 view 的一个参数叫做 <code>example</code> ， 绑定库会自动去寻找能接受对应类型参数的 setExample(arg) 方法。命名空间不会被使用到，只有参数名和类型会被用来查找对应的方法。<br>例如， <code>android:text=&quot;@{user.name}&quot;</code> 表达式中，数据绑定库会去查找 <code>setText(arg)</code> 方法，如果 <code>user.getName()</code> 的返回类型是 <code>String</code> ，数据绑定库就会去查找 <code>setText(String arg)</code> 方法，如果 <code>user.getName()</code> 的返回类型是 <code>int</code> ，数据绑定库就回去查找 <code>setText(int arg)</code> 方法。表达式的返回值类型必须相符，必要时可以使用 cast 转换。<br>在没有对应参数的情况下，数据绑定也可以正常工作。你甚至可以通过创建对应的 setter 函数来增加 xml 的参数。例如， Support 包下的 <code>DrawerLayout</code> 并没有什么特别的 xml 参数，但是他有好多 setter 函数。数据绑定库就会自动根据 <code>app:scrimColor</code> 和 <code>app:scrimColor</code> 参数来调用 <code>setScrimColor(int)</code> 和 <code>setDrawerListener(DrawerListener)</code> 方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">app:scrimColor</span>=<span class="string">"@&#123;@color/scrim&#125;"</span></div><div class="line">    <span class="attr">app:drawerListener</span>=<span class="string">"@&#123;fragment.drawerListener&#125;"</span>&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Specify-a-custom-method-name"><a href="#Specify-a-custom-method-name" class="headerlink" title="Specify a custom method name"></a>Specify a custom method name</h3><p>有些参数和它对应的 setter 方法名字并不匹配。在这种情况下，参数和对应的 setter 函数可以通过 <code>BindingMethods</code> 注解关联。注解用来修饰类，一个类可以有多个注解，每个注解声明了一个参数和 setter 的关联。例如 <code>android:tint</code> 对应的是 <code>setImageTintList(ColorStateList)</code> 而不是 <code>setTint()</code> 方法，这是我们就可以这么干：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingMethods</span>(&#123;</div><div class="line">       <span class="meta">@BindingMethod</span>(type = <span class="string">"android.widget.ImageView"</span>,</div><div class="line">                      attribute = <span class="string">"android:tint"</span>,</div><div class="line">                      method = <span class="string">"setImageTintList"</span>),</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>大多数情况下， Android 提供的类都不需要做重命名的映射，他们都进行了自动的方法匹配。  </p>
<h3 id="Provide-custom-logic"><a href="#Provide-custom-logic" class="headerlink" title="Provide custom logic"></a>Provide custom logic</h3><p>有些参数需要自定义的逻辑。例如， <code>android:paddingLeft</code> 没有对应的 <code>setPaddingLeft(left)</code> 方法，但是却提供了 <code>setPadding(left, top, right, bottom)</code> 方法。一个带有 <code>BindingAdapter</code> 注解的静态方法就可以让你完成自定义参数逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:paddingLeft"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPaddingLeft</span><span class="params">(View view, <span class="keyword">int</span> padding)</span> </span>&#123;</div><div class="line">  view.setPadding(padding,</div><div class="line">                  view.getPaddingTop(),</div><div class="line">                  view.getPaddingRight(),</div><div class="line">                  view.getPaddingBottom());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Android 提供的类也已经创建了相应的 <code>BindingAdapter</code> 注解。<br>上述代码参数类型很重要，第一个参数的类型决定了要在哪种类上关联参数，第二个参数的类型对应着表达式里面的类型。<br>BindindAdapters 可以用来做各种类型的自定义。例如，你可以在工作线程调用自定义的加载程序来加载图像。<br>当存在冲突的时候，你自定义的 adapter 会覆盖 Android 框架的 adapter 。<br>你也可以用 adapter 同时接收多个参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"imageUrl"</span>, <span class="string">"error"</span>&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</div><div class="line">  Picasso.with(view.getContext()).load(url).error(error).into(view);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相应地，你可以这样使用你定义的参数：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">app:imageUrl</span>=<span class="string">"@&#123;venue.imageUrl&#125;"</span> <span class="attr">app:error</span>=<span class="string">"@&#123;@drawable/venueError&#125;"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的例子中，只有当两个参数都被设置了的时候， adapter 才会生效，如果你想在仅有一个参数的情况下也使用 adapter ， 你可以吧注解的参数 <code>requireAll</code> 设置成 <code>false</code> ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(value=&#123;<span class="string">"imageUrl"</span>, <span class="string">"placeholder"</span>&#125;, requireAll=<span class="keyword">false</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(ImageView imageView, String url, Drawable placeHolder)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</div><div class="line">    imageView.setImageDrawable(placeholder);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    MyImageLoader.loadInto(imageView, url, placeholder);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Bindging adapter 方法还可以接收旧值作为参数。接收新旧参数的方法应该先声明所有的旧参数然后在声明新的参数，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:paddingLeft"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPaddingLeft</span><span class="params">(View view, <span class="keyword">int</span> oldPadding, <span class="keyword">int</span> newPadding)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (oldPadding != newPadding) &#123;</div><div class="line">      view.setPadding(newPadding,</div><div class="line">                      view.getPaddingTop(),</div><div class="line">                      view.getPaddingRight(),</div><div class="line">                      view.getPaddingBottom());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事件处理程序只能与只有一个抽象方法的接口或抽象类一起使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// View.OnLayoutChangeListener 接口只有一个方法。如果借口或者抽象类有多个方法的话，数据绑定库就知道该调用哪个方法了。</span></div><div class="line"><span class="meta">@BindingAdapter</span>(<span class="string">"android:onLayoutChange"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOnLayoutChangeListener</span><span class="params">(View view, View.OnLayoutChangeListeneroldValue,</span></span></div><div class="line">       View.OnLayoutChangeListener newValue) &#123;</div><div class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</div><div class="line">      view.removeOnLayoutChangeListener(oldValue);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</div><div class="line">      view.addOnLayoutChangeListener(newValue);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 layout 中这样使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">View</span> <span class="attr">android:onLayoutChange</span>=<span class="string">"@&#123;() -&gt; handler.layoutChanged()&#125;"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>当监听类有多个方法时，只能将它分成多个接口。例如， <code>View.OnAttachStateChangeListener</code> 中有两个方法：<code>onViewAttachedToWindow(View)</code> 和 <code>onViewDetachedFromWindow(View)</code> ，你必须创建两个接口来然后使用 BindingAdapter 创建两个参数，然后对应两个监听器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TargetApi</span>(VERSION_CODES.HONEYCOMB_MR1)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewDetachedFromWindow</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@TargetApi</span>(VERSION_CODES.HONEYCOMB_MR1)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnViewAttachedToWindow</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为改变一个监听器会影响另一个，你得需要一个能同时管理两个监听的 adapter 。你可以设置 BindingAdapter 注解的 <code>requireAll</code> 参数为 <code>false</code> ， 这样不用每次都得指定指定两个监听了：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"android:onViewDetachedFromWindow"</span>, <span class="string">"android:onViewAttachedToWindow"</span>&#125;     requireAll=<span class="keyword">false</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(View view, OnViewDetachedFromWindow detach, OnViewAttachedToWindow attach)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</div><div class="line">        OnAttachStateChangeListener newListener;</div><div class="line">        <span class="keyword">if</span> (detach == <span class="keyword">null</span> &amp;&amp; attach == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 如果 attach 监听和 detach 监听都为空的话，那就不需要给 view 设置  OnAttachStateChangeListener 了</span></div><div class="line">            newListener = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 设置监听</span></div><div class="line">            newListener = <span class="keyword">new</span> OnAttachStateChangeListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewAttachedToWindow</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (attach != <span class="keyword">null</span>) &#123;</div><div class="line">                        attach.onViewAttachedToWindow(v);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDetachedFromWindow</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (detach != <span class="keyword">null</span>) &#123;</div><div class="line">                        detach.onViewDetachedFromWindow(v);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取旧的 OnAttachStateChangeListener</span></div><div class="line">        OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view,newListener,</div><div class="line">                                              R.id.onAttachStateChangeListener);</div><div class="line">        <span class="comment">// 移除旧的 OnAttachStateChangeListener                                          </span></div><div class="line">        <span class="keyword">if</span> (oldListener != <span class="keyword">null</span>) &#123;</div><div class="line">            view.removeOnAttachStateChangeListener(oldListener);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 设置新的 OnAttachStateChangeListener</span></div><div class="line">        <span class="keyword">if</span> (newListener != <span class="keyword">null</span>) &#123;</div><div class="line">            view.addOnAttachStateChangeListener(newListener);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述示例要比正常的稍微复杂一些，因为 <code>View</code> 类用的是 <code>addOnAttachStateChangeListener()</code> 和 <code>removeOnAttachStateChangeListener()</code> 而不是 <code>onAttachStateChangeListener</code> 的 setter 方法。 <code>android.databinding.adapters.ListenerUtil</code> 这个类记录了以往了监听，以便在需要的时候用来移除。<br>通过对 <code>OnViewDetachedFromWindow</code> 和 <code>OnViewAttachedToWindow</code> 设置 <code>@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</code> 注解，绑定类生成器就知道只有在 API 12 以上才会生成相应的监听器，这个机制与 <code>addOnAttachStateChangeListener()</code> 相同。  </p>
<h2 id="Object-conversion"><a href="#Object-conversion" class="headerlink" title="Object conversion"></a>Object conversion</h2><h3 id="Automatic-object-conversion"><a href="#Automatic-object-conversion" class="headerlink" title="Automatic object conversion"></a>Automatic object conversion</h3><p>当绑定表达式返回一个 <code>Object</code> 时，由绑定库来调用相应的方法设置参数。 <code>Object</code> 对象会被根据方法的参数类型自动转型。这个行为在配合使用 <code>ObservableMap</code> 的时候尤其便利：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">   <span class="attr">android:text</span>=<span class="string">'@&#123;userMap["lastName"]&#125;'</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>在绑定表达式中使用的 <code>userMap</code> 对象会返回一个值，会被自动转为 <code>android:text</code> 所对应的 <code>setText(CharSequence)</code> 函数的的参数类型。如果参数类型不明确的话，必须要在表达式中手动转型。  </p>
<h3 id="Custom-conversions"><a href="#Custom-conversions" class="headerlink" title="Custom conversions"></a>Custom conversions</h3><p>在有些情况下，对于某些特定的类型必须要进行手动转型。例如， <code>android:background</code> 参数期待的是一个 <code>Drawable</code> 参数，但是 <code>color</code> 的值却是一个数字。下面的例子就展示了这种情况：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">View</span></span></div><div class="line">   <span class="attr">android:background</span>=<span class="string">"@&#123;isError ? @color/red : @color/white&#125;"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>当期待的是 <code>Drawable</code> 但是提供的却是 <code>int</code> 时， <code>int</code> 就需要被转为其颜色对应的 <code>ColorDrawable</code> 。转换可以通过给静态方法声明 <code>BindingConversion</code> 注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindingConversion</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorDrawable <span class="title">convertColorToDrawable</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ColorDrawable(color);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是，表达式里面提供的类型必须是一致的，不可以在同一个表达式里面返回不同的类型：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">View</span></span></div><div class="line">   <span class="attr">android:background</span>=<span class="string">"@&#123;isError ? @drawable/error : @color/white&#125;"</span> // 不可以的</div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h1 id="Bind-layout-views-to-Architecture-Components"><a href="#Bind-layout-views-to-Architecture-Components" class="headerlink" title="Bind layout views to Architecture Components"></a>Bind layout views to Architecture Components</h1><p>AndroidX 库中包含 <code>Architecture Components</code> ， 你可以用来设计健壮、可测试可维护的 APP 。数据绑定库可以和架构组件库无缝协作，进一步简化 UI 的开发。 APP 中的布局可以绑定架构组件的数据，可以帮助您管理 UI 控制器的生命周期和通知数据中的更改。    </p>
<h2 id="Use-LiveData-to-notify-the-UI-about-data-changes"><a href="#Use-LiveData-to-notify-the-UI-about-data-changes" class="headerlink" title="Use LiveData to notify the UI about data changes"></a>Use LiveData to notify the UI about data changes</h2><p>你可以使用 <code>LiveData</code> 对象作为数据绑定的数据源，来通知 UI 数据发生了更改。详细信息见 <code>LiveData</code> 的文档。<br>不像实现了 <code>Observable</code> 的对象， <code>LiveData</code> 知道订阅数据变更通知的观察者的生命周期。这带来了许多好处，在 <a href="https://developer.android.com/topic/libraries/architecture/livedata.html#the_advantages_of_using_livedata" target="_blank" rel="external">The advantages of using LiveData</a> 中有详细说明。在 Android Studio 3.1  以及更高版本中，你可以用 <code>LiveData</code> 来替换代码中的 observable fields 。<br>要在你的绑定类中使用 <code>LiveData</code> ，你需要指定一个生命周期所有者来定义 <code>LiveData</code> 对象的范围。下面的例子展示了在绑定类被初始化之后指定了 activity 作为生命周期所有者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></div><div class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</div><div class="line"></div><div class="line">        <span class="comment">// Specify the current activity as the lifecycle owner.</span></div><div class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以使用 <code>ViewModel</code> 组件，来将数据绑定到 layout 上。在 <code>ViewModel</code> 组件中，你可以使用 <code>LiveData</code> 来转换并且处理多个数据源。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScheduleViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</div><div class="line">    LiveData username;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleViewModel</span><span class="params">()</span> </span>&#123;</div><div class="line">        String result = Repository.userName;</div><div class="line">        userName = Transformations.map(result, result -&gt; result.value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Use-ViewModel-to-manage-UI-related-data"><a href="#Use-ViewModel-to-manage-UI-related-data" class="headerlink" title="Use ViewModel to manage UI-related data"></a>Use ViewModel to manage UI-related data</h2><p>数据绑定库可以和 <code>ViewModel</code> 组件无缝衔接， <code>ViewModel</code> 会将数据暴露给 layout 并对数据变化做出响应。结合 <code>ViewModel</code> 使用数据绑定可以将你的布局逻辑移至 <code>ViewModel</code> 中，这样可以更容易测试。数据绑定库负责在相应的时候绑定和解绑数据源。剩下的大部分工作都在于确保你暴露的数据的正确性。<br>要将 <code>ViewModel</code> 组件与数据绑定库一起使用，必须实例化继承了 <code>ViewModel</code> 的组件，再获取绑定类的实例，并将 <code>ViewModel</code> 示例赋值给绑定类相应的字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="comment">// Obtain the ViewModel component.</span></div><div class="line">        UserModel userModel = ViewModelProviders.of(getActivity())</div><div class="line">                                                    .get(UserModel.class);</div><div class="line"></div><div class="line">        <span class="comment">// Inflate view and obtain an instance of the binding class.</span></div><div class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</div><div class="line"></div><div class="line">        <span class="comment">// Assign the component to a property in the binding class.</span></div><div class="line">        binding.viewmodel = userModel;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 layout 中，使用绑定表达式将 <code>ViewModel</code> 中的字段和方法用在对应的 view 上：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></div><div class="line">    <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></div><div class="line">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;() -&gt; viewmodel.rememberMeChanged()&#125;"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Use-an-Observable-ViewModel-for-more-control-over-binding-adapters"><a href="#Use-an-Observable-ViewModel-for-more-control-over-binding-adapters" class="headerlink" title="Use an Observable ViewModel for more control over binding adapters"></a>Use an Observable ViewModel for more control over binding adapters</h2><p>你可以使用 <code>ViewModel</code> 实现 <code>Observable</code> 接口来同时 UI 数据变更，类似于使用 <code>LivaData。</code><br>在某些情况下，你可能会更偏向于使用 <code>ViewModel</code> 组件实现 <code>Observable</code> 接口，而不是直接使用 <code>LiveData</code> 对象，即使这意味着你得舍弃 <code>LiveData</code> 的生命周期管理功能。使用 <code>ViewModel</code> 实现 <code>Observable</code> 借口可以给予你 <code>Binding Adapter</code> 的更多控制权。下面的例子就能在数据变化的时候更好的控制通知，还允许你自定义方法在双向绑定中自定义参数的值。<br>要实现一个可观察的 <code>ViewModel</code> ，你先要继承 <code>ViewModel</code> 组件并实现 <code>Observable</code> 接口。当观察者使用  <code>addOnPropertyChangedCallback()</code> 和 <code>removeOnPropertyChangedCallback()</code> 订阅或者取消订阅时，你可以提供自定义逻辑。你还可以提供在 <code>notifyPropertyChanged()</code> 方法中属性更改时的自定义逻辑。示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A ViewModel that is also an Observable,</div><div class="line"> * to be used with the Data Binding Library.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObservableViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> PropertyChangeRegistry callbacks = <span class="keyword">new</span> PropertyChangeRegistry();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addOnPropertyChangedCallback</span><span class="params">(</span></span></div><div class="line">            Observable.OnPropertyChangedCallback callback) &#123;</div><div class="line">        callbacks.add(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeOnPropertyChangedCallback</span><span class="params">(</span></span></div><div class="line">            Observable.OnPropertyChangedCallback callback) &#123;</div><div class="line">        callbacks.remove(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Notifies observers that all properties of this instance have changed.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">()</span> </span>&#123;</div><div class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Notifies observers that a specific property has changed. The getter for the</div><div class="line">     * property that changes should be marked with the <span class="doctag">@Bindable</span> annotation to</div><div class="line">     * generate a field in the BR class to be used as the fieldId parameter.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> fieldId The generated BR id for the Bindable field.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyPropertyChanged</span><span class="params">(<span class="keyword">int</span> fieldId)</span> </span>&#123;</div><div class="line">        callbacks.notifyCallbacks(<span class="keyword">this</span>, fieldId, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mlaboratory.tech/2017/05/23/kotlin_bootstrap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T.M. Ma">
      <meta itemprop="description" content="just some notes">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17079743?v=3&s=466">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Timmy Ma">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/kotlin_bootstrap/" itemprop="url">
                  Kotlin Bootstrap
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-23 20:46:25" itemprop="dateCreated datePublished" datetime="2017-05-23T20:46:25+08:00">2017-05-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-05-26 14:56:45" itemprop="dateModified" datetime="2017-05-26T14:56:45+08:00">2017-05-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>May 17, 2017, at the Google I/O keynote, the Android team announced first-class support for Kotlin.</p>
</blockquote>
<p>Android团队已经宣布为 <a href="http://kotlinlang.org/" title="Kotlin 官网" target="_blank" rel="external">Kotlin</a> 提供 <strong>“first-class support”</strong><br>Kotlin 官网上对应 Android 的 <a href="https://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="external">tutorial</a><br>Android Developers 官网上对应 Kotlin 的 <a href="https://developer.android.com/kotlin/index.html" target="_blank" rel="external">start up</a>  </p>
<p>现在就橹一遍 <a href="http://try.kotlinlang.org/koans" target="_blank" rel="external">“hands-on” learning</a> 吧<br>希望不会像 Swift 那样</p>
<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world"></a>Hello, world</h1><p><code>fun</code> 关键字后面跟上 <code>函数名</code><br>括号里面是 <code>参数名: 参数类型</code><br>括号后面跟上 <code>返回值类型</code> （void 就不用写）<br><code>返回值类型</code> 后面可以跟上 <code>?</code> 代表返回值可以为空</p>
<pre><code>fun main(args: Array&lt;String&gt;) {  
    println(&quot;Hello, world!&quot;)  
}
</code></pre><p><code>main</code> 函数、命令行参数什么的就略过了吧</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p><code>if</code> 在 Kotlin 中是表达式，具有返回值</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    println(max(args[0].toInt(), args[1].toInt()))
}

fun max(a: Int, b: Int) = if (a &gt; b) a else b
</code></pre><p>没错，函数的返回值也可以用 <code>=</code> 简写</p>
<h2 id="Null-检查"><a href="#Null-检查" class="headerlink" title="Null 检查"></a>Null 检查</h2><blockquote>
<p>A reference must be explicitly marked as nullable to be able hold a null.</p>
</blockquote>
<p>一个引用必须被明确的标记为 <code>nullable</code> 以便能被赋值为 <code>null</code>  </p>
<pre><code>package multiplier

// 如果 str 不是数字则返回 null
// 这里的问号即标记返回值可为 null
fun parseInt(str: String): Int? {
    try {
        return str.toInt()
    } catch (e: NumberFormatException) {
        println(&quot;One of the arguments isn&apos;t Int&quot;)
    }
    return null
}

fun main(args: Array&lt;String&gt;) {
    if (args.size &lt; 2) {
        println(&quot;No number supplied&quot;);
    } else {
        val x = parseInt(args[0])
        val y = parseInt(args[1])

        // 不能直接写 &apos;x * y&apos; 因为他们还有可能为 null
        if (x != null &amp;&amp; y != null) {
            print(x * y) // Now we can
        } else {
            println(&quot;One of the arguments is null&quot;)
        }
    }
}
</code></pre><p>听说能减少一半以上的 <code>NullPointerException</code> ？  </p>
<h2 id="is-Check-和-自动-cast"><a href="#is-Check-和-自动-cast" class="headerlink" title="is Check 和 自动 cast"></a>is Check 和 自动 cast</h2><p>使用 <code>is</code> 来检查某个引用是否为某种类型的实例等等<br>如果我们已经 check 过了某种 <code>immutable</code> 的类型，在之后的使用就无需将其进行类型转换  </p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    println(getStringLength(&quot;aaa&quot;))
    println(getStringLength(1))
}

fun getStringLength(obj: Any): Int? {
    if (obj is String)
        return obj.length // 无需 cast 成 String
    return null
}
</code></pre><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p><code>while</code> 和 <code>do..while</code> 同 java</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    var i = 0
    while (i &lt; args.size)
        println(args[i++])
}
</code></pre><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>给一个 <code>iterable</code> 的对象就能循环</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    for (arg in args)
        println(arg)

    // or
    println()
    for (i in args.indices)
        println(args[i])
}
</code></pre><h2 id="range-和-in"><a href="#range-和-in" class="headerlink" title="range 和 in"></a>range 和 in</h2><p><code>&lt;num1&gt;..&lt;num2&gt;</code> 返回的是一个 <code>iterable</code> 对象<br><code>in</code> 操作符可以用来检查值是否在范围中，也可以在 <code>for</code> 循环里面 loop  </p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    val x = args[0].toInt()
    // 检查数字是否在范围内
    val y = 10
    if (x in 1..y - 1)
        println(&quot;OK&quot;)

    // 在一个范围内枚举
    for (a in 1..5)
        print(&quot;${a} &quot;)

    // 检查数字是否超出范围
    println()
    val array = arrayListOf&lt;String&gt;()
    array.add(&quot;aaa&quot;)
    array.add(&quot;bbb&quot;)
    array.add(&quot;ccc&quot;)

    if (x !in 0..array.size - 1)
        println(&quot;Out: array has only ${array.size} elements. x = ${x}&quot;)

    // 检查一个 collection 是否包含某个 object
    if (&quot;aaa&quot; in array) // collection.contains(obj) 被调用
        println(&quot;Yes: array contains aaa&quot;)

    if (&quot;ddd&quot; in array) // collection.contains(obj) 被调用
        println(&quot;Yes: array contains ddd&quot;)
    else
        println(&quot;No: array doesn&apos;t contains ddd&quot;)
}
</code></pre><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p><code>when</code> 取代 java 中的 <code>switch..case</code>，很白话  </p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    cases(&quot;Hello&quot;)
    cases(1)
    cases(0L)
    cases(MyClass())
    cases(&quot;hello&quot;)
}

fun cases(obj: Any) {
    when (obj) {
        is String -&gt; println(&quot;a string&quot;)
        1 -&gt; println(&quot;One&quot;)
        &quot;Hello&quot; -&gt; println(&quot;Greeting&quot;)
        is Long -&gt; println(&quot;Long&quot;)
        !is String -&gt; println(&quot;Not a string&quot;)
        else -&gt; println(&quot;Unknown&quot;)
    }
}

class MyClass() {
}
</code></pre><h1 id="Destructuring-声明-和-Data-类"><a href="#Destructuring-声明-和-Data-类" class="headerlink" title="Destructuring 声明 和 Data 类"></a>Destructuring 声明 和 Data 类</h1><h2 id="Destructuring-（解构？）声明"><a href="#Destructuring-（解构？）声明" class="headerlink" title="Destructuring （解构？）声明"></a>Destructuring （解构？）声明</h2><p><code>val (name, age) = person</code> 这样的声明可以将对象 destructure（对象并不会被销毁）成几个变量<br>一句 destructuring declaration 会被编译成一下代码  </p>
<pre><code>val name = person.component1()
val age = person.component2()
</code></pre><p>前提是你需要在你的类中定义这样的方法（如果声明成 <code>data</code> 类就会自动实现 <code>componentN</code> 的方法）</p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    val pair = Pair(1, &quot;one&quot;)

    val (num, name) = pair

    println(&quot;num = $num, name = $name&quot;)
}

// 泛型还是这么用没有问题的
class Pair&lt;K, V&gt;(val first: K, val second: V) {
    operator fun component1(): K {
        return first
    }

    operator fun component2(): V {
        return second
    }
}
</code></pre><h2 id="data-类"><a href="#data-类" class="headerlink" title="data 类"></a>data 类</h2><p>将类声明为 <code>data</code> 类，可以由编译器自动根据主构造函数参数自动生成：  </p>
<ul>
<li>equals() / hashCode()</li>
<li>toString() 以 “User(name=John, age=42)” 这样的格式</li>
<li>componentN() 按照声明的顺序生成对应成员的 componentN()</li>
<li>copy() <strong>深度拷贝？还没试</strong></li>
</ul>
<h2 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h2><pre><code>fun main(args: Array&lt;String&gt;) {
    val map = hashMapOf&lt;String, Int&gt;()
    map.put(&quot;one&quot;, 1)
    map.put(&quot;two&quot;, 2)

    for ((key, value) in map) {
        println(&quot;key = $key, value = $value&quot;)
    }
}
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mlaboratory.tech/2016/09/17/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T.M. Ma">
      <meta itemprop="description" content="just some notes">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17079743?v=3&s=466">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Timmy Ma">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/17/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-17 20:25:34" itemprop="dateCreated datePublished" datetime="2016-09-17T20:25:34+08:00">2016-09-17</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars1.githubusercontent.com/u/17079743?v=3&s=466"
                alt="T.M. Ma" />
            
              <p class="site-author-name" itemprop="name">T.M. Ma</p>
              <p class="site-description motion-element" itemprop="description">just some notes</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/TimmyMa" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://stackoverflow.com/users/6305640/timmyma" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T.M. Ma</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.3.7</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
